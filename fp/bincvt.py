#!/usr/bin/env python3

import math


def padto(s: str, n: int, val: str = '0'):
    while len(s) < n:
        s += val
    return s


def leftpad(s: str, n: int, val: str = '0'):
    while len(s) < n:
        s = val + s
    return s


_DEBUG = 0


def log(msg: str) -> None:
    if _DEBUG:
        print(msg)


def frombinary16(s: str) -> float:
    s = s.strip()
    s = s.replace(' ', '')
    if s.startswith('0b'):
        s = s[2:]
    if len(s) != 16:
        raise ValueError('Invalid length for binary16')
    sign = int(s[0])
    exponent = s[1:6]
    mantissa = s[6:16]
    log(f"Sign:     {sign}")
    log(f"Exponent: {exponent}")
    log(f"Mantissa: {mantissa}")
    eint = int(exponent, 2)
    mint = int(mantissa, 2)
    s = '+' if sign != 0 else '-'
    if eint == 0b00000 and mint == 0:
        m = 0
        log(f"{s}zero")
    elif eint == 0b11111 and mint == 0:
        m = float('inf')
        log(f"{s}infinity")
    elif eint == 0b11111 and mint != 0:
        log("NaN")
        m = float('nan')
    elif eint == 0b00000 and mint != 0:
        m = mint / 2**10 * 2**-14
        log(f"subnormal: (-1)^{sign} x 0.{mantissa} x 2^-14 = {m}")
    else:
        m = (1 + mint / 2**10) * 2**(eint - 15)
        log(f"(-1)^{sign} x 1.{mantissa} x 2^{eint - 15} = {m}")
    return m


def check(result: str, exponent: int):
    first, second = result.split('.')
    integral = float(int(first, 2))
    mantissa = 0.0
    i = 1
    for c in second:
        if c == '1':
            mantissa += 1 / math.pow(2, i)
        i += 1
    final = integral + mantissa
    final = final * math.pow(2, exponent)
    log(f"{result} x 2**{exponent} = {final}")


def tobinary16(s: float) -> str:
    log(f"tobinary16({s})")
    s = float(s)
    sign = 0 if s >= 0 else 1
    s = abs(s)
    integral = int(s)
    fraction = s - integral
    mantissa1 = bin(integral)[2:]
    mantissa2 = ''
    # TODO: how far do I need to go?
    for i in range(32):
        x = 1 / math.pow(2, i+1)
        if fraction >= x:
            fraction -= x
            mantissa2 += '1'
        else:
            mantissa2 += '0'
    log(f"sign     = {sign}")
    log(f"mantissa = {mantissa1}.{mantissa2}")
    exponent = 0
    if mantissa1[0] == '1':
        exponent = len(mantissa1) - 1
        result = mantissa1[0] + '.'
        if len(mantissa1) > 1:
            result += mantissa1[1:]
        result += mantissa2
    else:
        i = mantissa2.find('1')
        if i == -1:
            result = '0.0000000000'
            exponent = 0
        else:
            exponent = -1 * i - 1
            result = mantissa2[i] + '.'
            if len(mantissa2) > i:
                result += mantissa2[i+1:]
    result = padto(result, n=10+1+1, val='0')
    result = result[0:10+1+1]
    log(f"Result: {result} x 2**{exponent}")
    check(result, exponent)
    # TODO: generate sub-normals
    # exponent := [1, 31) => [-14, 16)
    if exponent < -14:    # round to zero
        assert result[1] == '.'
        mantissa = result[0] + result[2:]
        while exponent < -14:
            mantissa = '0' + mantissa[0:9]
            exponent += 1
            if mantissa == '0000000000':
                exponent = 0
                break
        exp = '00000'
        # result = '0000000000'
        # exp = bin(exponent)[2:]
        result = mantissa
    elif exponent >= 16:  # round to infinity
        exp = '11111'
        result = '0000000000'
    else:
        exp = bin(exponent + 15)[2:]
        result = result[2:12]

    exp = leftpad(exp, 5, '0')
    if len(exp) != 5:
        raise ValueError(f"Invalid exponent: {exp}")
    mant = padto(result, 10, '0')
    log(f"Sign     = {sign}")
    log(f"Exponent = {exp}")
    log(f"Mantissa = {mant}")
    return f'{sign}{exp}{mant}'


cs = [
    # (1.0, 1.0),
    # (1.5, 1.0),
    # (0.5, 1.0),
    # (0.5, 10.1),
    # (1.5, 10.1),
    # (1.5, 100.1),
    # (1.5, 100.01),
    # (0.01, 100.01),
    (0.00001, 0.00001),
    # (1.00001, 5.00001),
]
print(f'TEST_CASE("Autogenerated add tests")')
print(f'{{')
for x, y in cs:
    z = x + y
    binary16_x = tobinary16(x)
    binary16_y = tobinary16(y)
    binary16_z = tobinary16(z)
    log(frombinary16(binary16_x))
    log(frombinary16(binary16_y))
    log(frombinary16(binary16_z))
    print(f'    SECTION("{x} + {y} = {z}")')
    print(f'    {{')
    print(f'         binary16 x = binary16_fromrep(0b{binary16_x}); // {x}')
    print(f'         binary16 y = binary16_fromrep(0b{binary16_y}); // {y}')
    print(f'         binary16 z = binary16_fromrep(0b{binary16_z}); // {z}')
    print(f'         binary16 a = binary16_add(x, y);')
    print(f'         INFO("x = {x:.10f} = " << binary16_tofloat(x) << " = " << binary16_torep(x));')  # noqa
    print(f'         INFO("y = {y:.10f} = " << binary16_tofloat(y) << " = " << binary16_torep(y));')  # noqa
    print(f'         INFO("z = {z:.10f} = " << binary16_tofloat(z) << " = " << binary16_torep(z));')  # noqa
    print(f'         INFO("a                = " << binary16_tofloat(a) << " = " << binary16_torep(a));')  # noqa
    print(f'         CHECK(a.rep == z.rep);')
    print(f'    }}')
print(f'}}')


# vs = [
#     1.5,
#     5.5,
#     1.0,
#     1.1,
#     0.5,
#     0.625,
# ]
# for v in vs:
#     r1 = tobinary16(v)
#     print(f"tobinary16({v}")
#     print(f"Result = {r1}")
#     r2 = frombinary16(r1)
#     print(f"Result = {r2}")
#     print()


def dec2bin(s: str) -> str:
    """
    Convert string form of a decimal number its binary form.

    TODO: need to investigate more where this breaks down, e.g. 0.1
    """
    s = s.strip()
    f = float(s)
    frac, intr = math.modf(f)
    sint = bin(int(intr))[2:]
    n = 1
    while frac != float(int(frac)):
        frac *= 10
        n *= 10
    m = math.ceil(math.log(n, 2))
    val = (frac * 2**m) / n
    # assert val == float(int(val)), f"val should be an integer: {val}"
    sfrac = bin(int(val))[2:]
    sfrac = sfrac.rstrip('0')
    return f"{sint}.{sfrac}"


def bin2dec(s: str) -> str:
    """
    Convert string form of a binary number its decimal form.
    """

    s = s.strip()
    n = 0
    m = 0
    i = 0
    N = len(s)
    while i < N and s[i] != '.':
        n *= 2
        if s[i] == '1':
            n += 1
        elif s[i] == '0':
            n += 0
        else:
            raise ValueError(f"Invalid binary digit: {s[i]}")
        i += 1
    if i < N and s[i] == '.':
        i += 1
    z = 1.0
    for j in range(i, N):
        z /= 2
        if s[j] == '1':
            m += z
        elif s[j] == '0':
            m += 0
        else:
            raise ValueError(f"Invalid binary digit: {s[j]}")
    r = m + n
    return str(r)


def getparts(sbin: str):
    Binary16_ExponentBias = 15
    Binary16_ExponentBits = 5
    Binary16_FractionBits = 10

    intr, frac = sbin.split('.')
    # print(f"intr = {intr} frac = {frac}")
    n = len(intr)
    # TODO: handle < 1 case
    # TODO: handle negatives
    assert intr[0] == '1', 'only handling >= 1 case'
    exp = n - 1
    if len(intr) > 1:
        sfrac = intr[1:] + frac
    else:
        sfrac = frac
    sign = 0
    print(f"(-1)**{sign} x 1.{sfrac} x 2^{exp}")
    signbits = '0'
    biasedexp = exp + Binary16_ExponentBias
    bexpbits = bin(biasedexp)[2:]
    if len(bexpbits) > Binary16_ExponentBits:
        raise ValueError(f"Exponent: {exp} unable to fit in exponent")
    bexpbits = padto(bexpbits, Binary16_ExponentBits)
    fracbits = padto(sfrac, Binary16_FractionBits)
    if len(fracbits) > Binary16_FractionBits:
        print(f"warn: dropping some fraction bits from {fracbits}")
    fracbits = fracbits[0:Binary16_FractionBits]

    result = f"{signbits}{bexpbits}{fracbits}"
    print(f"Signbits: {signbits}")
    print(f"BExpbits: {bexpbits} ({int(bexpbits, 2)})")
    print(f"Fracbits: {fracbits}")
    print(f"IEEE    : {result}")
