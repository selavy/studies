// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAFSA_H_
#define FLATBUFFERS_GENERATED_MAFSA_H_

#include "flatbuffers/flatbuffers.h"

struct SerialLink;

struct SerialNode;
struct SerialNodeBuilder;

struct SerialMafsa;
struct SerialMafsaBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SerialLink FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;
  int32_t next_;

 public:
  SerialLink() {
    memset(static_cast<void *>(this), 0, sizeof(SerialLink));
  }
  SerialLink(int32_t _value, int32_t _next)
      : value_(flatbuffers::EndianScalar(_value)),
        next_(flatbuffers::EndianScalar(_next)) {
  }
  int32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
  int32_t next() const {
    return flatbuffers::EndianScalar(next_);
  }
};
FLATBUFFERS_STRUCT_END(SerialLink, 8);

struct SerialNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_TERM = 6,
    VT_CHILDREN = 8
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool term() const {
    return GetField<uint8_t>(VT_TERM, 0) != 0;
  }
  const flatbuffers::Vector<const SerialLink *> *children() const {
    return GetPointer<const flatbuffers::Vector<const SerialLink *> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyField<uint8_t>(verifier, VT_TERM) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.EndTable();
  }
};

struct SerialNodeBuilder {
  typedef SerialNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(SerialNode::VT_VALUE, value, 0);
  }
  void add_term(bool term) {
    fbb_.AddElement<uint8_t>(SerialNode::VT_TERM, static_cast<uint8_t>(term), 0);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<const SerialLink *>> children) {
    fbb_.AddOffset(SerialNode::VT_CHILDREN, children);
  }
  explicit SerialNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialNode> CreateSerialNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    bool term = false,
    flatbuffers::Offset<flatbuffers::Vector<const SerialLink *>> children = 0) {
  SerialNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_value(value);
  builder_.add_term(term);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialNode> CreateSerialNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    bool term = false,
    const std::vector<SerialLink> *children = nullptr) {
  auto children__ = children ? _fbb.CreateVectorOfStructs<SerialLink>(*children) : 0;
  return CreateSerialNode(
      _fbb,
      value,
      term,
      children__);
}

struct SerialMafsa FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerialMafsaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SerialNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SerialNode>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct SerialMafsaBuilder {
  typedef SerialMafsa Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SerialNode>>> nodes) {
    fbb_.AddOffset(SerialMafsa::VT_NODES, nodes);
  }
  explicit SerialMafsaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SerialMafsa> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerialMafsa>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerialMafsa> CreateSerialMafsa(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SerialNode>>> nodes = 0) {
  SerialMafsaBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerialMafsa> CreateSerialMafsaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SerialNode>> *nodes = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<SerialNode>>(*nodes) : 0;
  return CreateSerialMafsa(
      _fbb,
      nodes__);
}

inline const SerialMafsa *GetSerialMafsa(const void *buf) {
  return flatbuffers::GetRoot<SerialMafsa>(buf);
}

inline const SerialMafsa *GetSizePrefixedSerialMafsa(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SerialMafsa>(buf);
}

inline const char *SerialMafsaIdentifier() {
  return "MFSA";
}

inline bool SerialMafsaBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SerialMafsaIdentifier());
}

inline bool VerifySerialMafsaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SerialMafsa>(SerialMafsaIdentifier());
}

inline bool VerifySizePrefixedSerialMafsaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SerialMafsa>(SerialMafsaIdentifier());
}

inline const char *SerialMafsaExtension() {
  return "mfsa";
}

inline void FinishSerialMafsaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SerialMafsa> root) {
  fbb.Finish(root, SerialMafsaIdentifier());
}

inline void FinishSizePrefixedSerialMafsaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SerialMafsa> root) {
  fbb.FinishSizePrefixed(root, SerialMafsaIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAFSA_H_
